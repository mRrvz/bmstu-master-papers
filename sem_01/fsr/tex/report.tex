\documentclass[12pt, a4paper]{article}

\include{preamble}

\begin{document}


\noindent УДК~004.94

\hfill

\noindent \textbf{Объединение страниц оперативной памяти, содержащих одинаковые данные, сжатых модулем ядра Linux}

\noindent А.~В.~Романов$^{1}$\hfill romanov.alexey2000@gmail.com

\noindent $^{1}$МГТУ им.~Н.~Э.~Баумана, Москва, Россия

\hfill

\noindent \textbf{Аннотация}

\noindent Статья посвящена оптимизациям в подсистеме управления памяти в ядре Linux. Кратко описаны главные концепции управления памятью в ядре Linux. Описаны структуры данных и алгоритм работы модуля ядра zram, отвечающего за сжатие страниц оперативной памяти. Разработан метод объединения страниц оперативной памяти содержащие одинаковые данные, которые предварительно были сжаты соответствующим модулем ядра Linux. Проведён анализ результатов работы разработанного алгоритма на различных архитектурах процессора и на разных входных данных.

\noindent \textbf{Ключевые слова}

\noindent \textit{операционные системы, ядро Linux, управление памятью, zram, сжатие данных, дедупликация данных}

\hfill

\section*{Введение}

Существует несколько способов увеличения количества оперативной памяти. Один из способов заключается в физическом увеличении количества планок ОЗУ в системе. Данный способ подразумевает покупку и установку планок ОЗУ, что требует денежных затрат. Кроме физического способа увеличения количества памяти, существуют программные способы увеличения количества ОЗУ, например, сжатие данных. Данный способ требует только вычислительные мощности CPU. Кроме того, к программным способам, можно отнести дедупликацию данных -- объединение участков в памяти, содержащих одинаковые данные, в одно целое. Два последних способа можно объединить и получить ещё один наиболее эффективный способ увеличения количества оперативной памяти: дедупликация сжатых данных.

\section{Управление памятью в ядре Linux}

Ядро Linux использует страничную организацию памяти. Суть этого метода заключается в том, что вся физическая память разделена на страницы одинакового размера, называющиеся страницами памяти. Чаще всего, размер такой страницы равен 4096 байт, но это число является архитектурно зависимым, и может отличаться от архитектуры к архитектуре. В Linux оно задано константой \texttt{PAGE\_SIZE}.

Благодаря механизму страничной организации памяти реализуется механизм виртуальной памяти. Виртуальная память -- метод управления памятью, при котором физический адрес каждой ячейки памяти автоматически (обычно аппаратно) транслируется в некоторый логический адрес и наоборот. Каждое такое соответствие однозначно. При таком методе управления памятью, программы всегда взаимодействуют с логическими адресами. Благодаря этому, в ядре Linux решаются следующие задачи:

\begin{itemize}
	\item изоляция адресного пространства процессов друг от друга;
	\item возможность использовать больше оперативной памяти, чем её установлено в системе;
	\item устранение необходимости управлять общим адресным пространством.
\end{itemize}

Каждая физическая страница памяти в исходном коде ядра Linux описывается структурой \texttt{struct page}, которая представлена в листинге \ref{code:struct_page}. Представлены лишь наиболее важные поля структуры -- большая часть полей структуры используется в различных ситуациях по разному, поэтому описывать их здесь не имеет смысла.

\begin{code}
	\captionof{listing}{Структура \texttt{struct page}}
	\label{code:struct_page}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/struct_page.c}
\end{code}

Опишем подробно поля, указанные в листинге рассматриваемой структуры:

\begin{itemize}
	\item \texttt{flags} -- переменная, содержащая флаги, описывающие данную страницу памяти;
	\item \texttt{private} -- специальное поле для хранения различных данных;
	\item \texttt{\_refcount} -- счетчик ссылок на страницу;
	\item \texttt{\_mapcount} -- количество записей таблицы страниц, ссылающихся на страницу;
	\item \texttt{lru} -- указатель на двунаправленный список давно неиспользуемых страниц.
\end{itemize}

\section{Структуры данных и схема работы модуля ядра zram}

zram -- модуль ядра Linux, предназначенный для сжатия содержимого страниц оперативной памяти на лету и дальнейшего их сохранения в памяти. При использовании этого модуля можно увеличить эффективный размер оперативной памяти системы. Так, например, если некоторая система физически ограничена оперативной памятью размером 4 гигабайта, при среднем коэффициент сжатия $k = \frac{1}{2}$ эффективный размер оперативной памяти увеличивается до 8 гигабайт. Но, стоит отметить: из-за того что сжатие -- затратная операция (с точки зрения CPU), рассматриваемый модуль ядра чаще всего используют в ситуациях, когда в системе мало свободной оперативной памяти. В противном случае, при попытках сжатия всей доступной  памяти, это бы приводило к уменьшению отзывчивости системы.

Единицей диспетчеризации zram является страница памяти. То есть, данный модуль работает со страницами памяти (со структурой \texttt{struct page}), сжимая данные, которые в них хранятся. Модуль zram создает специальное блочное устройство, находящееся в оперативной памяти, которое обрабатывает страницы памяти. Так, например, при попытке записи какого-либо файла в такое блочное устройство, содержимое файла будет разбито на страницы размером \texttt{PAGE\_SIZE}, которые в последствии будут сжаты и сохранены в оперативной памяти.

Каждая сжатая страница внутри модуля ядра zram описывается структурой \texttt{struct zram\_table\_entry}, которая представлена в листинге \ref{code:zram_table_entry}. Массив таких структур хранится внутри структуры \texttt{struct zram}.

\begin{code}
	\captionof{listing}{Структура \texttt{struct zram\_table\_entry}}
	\label{code:zram_table_entry}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/zram_table_entry.c}
\end{code}

Опишем поля рассматриваемой структуры:

\begin{itemize}
	\item \texttt{handle} -- некоторое закодированное число, ссылка на адрес в памяти, где хранится сжатые данные исходной страницы памяти;
	\item \texttt{element} -- если исходная страница состоит из одного и того же элемента, то сохраняется только этот элемент. Так, например, если каждый байт страницы равен нулю, то в поле element будет сохранено 0;
	\item \texttt{flags} -- флаги, описывающие сжатую страницу памяти. Например, если страница состоит из одинаковых элементов, она будет помечена специальным флагом -- то есть у переменной \texttt{flags} будет выставлен некоторый бит, отвечающий за этот флаг;
\end{itemize}

zram использует специально спроектированный аллокатор zsmalloc, целью которого является эффективное распределение памяти при маленьком количестве свободной оперативной памяти. В отличии от наиболее используемого подхода, когда пользователь запрашивает у аллокатора участок памяти размера $n$ и на выходе получает указатель на начало этого участка, zsmalloc возвращает некоторое целое без знаковое число, являющееся специальным образом закодированным указателем на необходимую область памяти. Далее, необходимо передать это число в специальную функцию, представленной в интерфейсе аллокатора, и только после этого получить необходимый адрес на запрашиваемый участок памяти. Такая особенность связана с внутренней реализацией zsmalloc, и позволяет добиться наиболее эффективного распределения памяти. В листинге \ref{code:zsmalloc_api} представлено API для работы с данным аллокатором.

\begin{code}
	\captionof{listing}{API для работы с zsmalloc}
	\label{code:zsmalloc_api}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/zsmalloc_api.c}
\end{code}

Рассмотрим подробнее API для работы с аллокатором zsmalloc:

\begin{itemize}
	\item \texttt{zs\_create\_pool} -- создать некоторый пулл, в котором в дальнейшем будут выделяться объекты;
	\item \texttt{zs\_destroy\_pool} -- уничтожить пулл объектов;
	\item \texttt{zs\_malloc} -- выделить объект размером \texttt{size} внутри пулла \texttt{pool}. Возвращает целое без знаковое число;
	\item \texttt{zs\_free} -- освободить ранее выделенный функцией \texttt{zs\_malloc} объект;
	\item \texttt{zs\_map\_object} -- получить соответствие между числом (\texttt{handle}), которое вернула функция \texttt{zs\_malloc} и указателем на выделенную областью памяти, то есть получить указатель на начало выделенного аллокатором участка памяти. Из-за внутренних особенностей архитектуры zsmalloc, в один момент времени может быть получено не более одного соответствия между \texttt{handle} и указателем на выделенную область памяти;
	\item \texttt{zs\_unmap\_object} -- убрать соответствие между \texttt{handle} и адресом на выделенную акллокатором память. После вызова этой функции, обращаться к выделенному участку памяти запрещено. 
\end{itemize}

Таким образом, поле \texttt{handle} структуры \texttt{struct zram\_table\_entry} -- это закодированный указатель на область памяти, который вернула функция \texttt{zs\_malloc}, в которой хранятся сжатые данные страницы, доступ к которым можно получить с помощью функции \texttt{zs\_map\_object}.

На рисунке \ref{fig:zram} представлена концептуальная схема работы модуля ядра zram и его взаимодействие со всей системой.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{img/zram-arch.pdf}
	\caption{Схема работы модуля ядра zram}
	\label{fig:zram}
\end{figure}

Приведем алгоритм работы zram при попытки записи в блочное устройство:

\begin{enumerate}
	\item содержимое каждой страницы памяти, попавшее в блочное устройство, сжимается и записывается во временный буффер;
	\item у аллокатора zsmalloc запрашивается участок памяти, с помощью функции \texttt{zs\_malloc}, равный размеру сжатых данных;
	\item происходит сопоставление закодированного указателя \texttt{handle} и выделенной областью памяти с помощью функции \texttt{zs\_map\_object};
	\item сжатые данные копируются из временного буффера, в область памяти выделенную аллокатором. Временный буффер освобождается.
	\item заполняется соответствующая ячейка массива структур \texttt{zram\_table\_entry}. В структуре сохраняется указатель на объект --  \texttt{handle} и в переменную \texttt{flags} устанавливаются флаги, описывающие сжатые данные обрабатываемой страницы. 
\end{enumerate}

Алгоритм чтения из блочного устройства аналогичен алгоритму записи.

\section{Алгоритм объединения содержимого страниц оперативной памяти}

Рассмотрим ситуацию, представленную на рисунке \ref{fig:zram-duplicates}. 

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{img/zram-duplicates.pdf}
	\caption{Страницы с одинаковым содержимым}
	\label{fig:zram-duplicates}
\end{figure}

Три страницы с одинаковым содержимым соответствуют трём разным структурам \texttt{struct zram\_table\_entry}, которые в свою очередь хранят закодированный указатель на данные. Сжатые данные, хранящиеся внутри аллокатора zsmalloc, дублируют друг друга. В данном примере, при сжатом размере страницы равным $n$ байт, модуль zram использует $3 * n$ байт памяти, вместо того чтобы использовать $n$ байт. 
Этого можно добиться заменив закодированные указатели \texttt{handle Y} и \texttt{handle Z} на \texttt{handle X}, освободить участки памяти внутри zsmalloc, на которые они указывают и добавить счётчик ссылок на объект, на который указывает \texttt{handle X}. Таким образом, можно сохранить $2 * n$ байт оперативной памяти. Данная оптимизация представлена на рисунке \ref{fig:zram-no-duplicates}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{img/zram-no-duplicates.pdf}
	\caption{Дедупликация данных}
	\label{fig:zram-no-duplicates}
\end{figure}


\section{Сравнительный анализ результатов работы разработанного алгоритма}

\section*{Заключение}


\begin{thebibliography}{5}
	%\bibitem{1} Градов В. М. Курс лекций по моделированию. МГТУ им. Н. Э. Баумана.
	%\bibitem{2} Абдурагимов Э. И. Метод сеток решения задачи Дирихле для уравнения Пуассона. ДГУ
\end{thebibliography}

\noindent \textbf{Романов Алексей Васильевич} — студент, МГТУ им. Н. Э. Баумана, кафедра «Программное обеспечение ЭВМ и информационные технологии».


\end{document}
